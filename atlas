#!/bin/bash
# getoptions generates code that fails this check, so we need to disable it
# shellcheck disable=SC2004

# @getoptions
parser_definition() {
	setup       REST help:usage -- \
				"Atlas is a CLI tool that has essentially one command: \`atlas pull\`\n \nAtlas defaults to using a configuration file named \`atlas.yml\` placed\nin the root directory. Configuration file:\n \npull:\n  branch: <branch-name>\n  directory <directory-name>\n  repository: <organization-name>/<repository-name>\n \nAtlas can also use a configuration file in a different path using the \`--config\` flag\nafter \`atlas\`: \`atlas pull --config config.yml\`.\n \nAtlas can also be used without a configuration file by using the flags below after\n\`atlas pull\`.\n \n\`-b\` or \`--branch\`\n\`-r\` or \`--repository\`\n\`-d\` or \`--directory\`" ''
	msg 	 -- '' 'Commands:'
	cmd pull -- "pull"
	disp    :usage  -h --help
}

parser_definition_pull() {
	setup   REST help:usage_pull -- \
		"Usage: atlas pull [options...] [arguments...]"
	msg -- 'Options:'
	param		CONFIG			--config			-- "path to alternative atlas.yaml configuration file"
	param		BRANCH		-b	--branch			-- "A branch of translation files"
	param		REPOSITORY	-r	--repository		-- "The repository containing translation files"
	param		DIRECTORY	-d	--directory			-- "Directory (name of the repository) containing translations to be downloaded"
	param		FILTER	    -f	--filter			-- "List of patterns to select which files and sub-directories to checkout."
	flag		VERBOSE		-v	--verbose			-- "verbose output to terminal"
	flag		SILENT		-s	--silent			-- "no output to terminal"
	flag		DRY_RUN		-n	--dry-run			-- "Do not copy files. Print sparse-checkout rules, git checkout tree and copied tree."
	disp    :usage_pull  -h --help
}
# @end

# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[h]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '-h'|'--help')
        usage
        exit 0 ;;
      --)
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        case $1 in 'pull') ;;
          *) set "notcmd" "$1"; break
        esac
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Atlas is a CLI tool that has essentially one command: `atlas pull`
 
Atlas defaults to using a configuration file named `atlas.yml` placed
in the root directory. Configuration file:
 
pull:
  branch: <branch-name>
  directory <directory-name>
  repository: <organization-name>/<repository-name>
 
Atlas can also use a configuration file in a different path using the `--config` flag
after `atlas`: `atlas pull --config config.yml`.
 
Atlas can also be used without a configuration file by using the flags below after
`atlas pull`.
 
`-b` or `--branch`
`-r` or `--repository`
`-d` or `--directory`


Commands:
  pull      pull
  -h, --help                  
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end

# @gengetoptions parser -i parser_definition_pull parse_pull
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
CONFIG=''
BRANCH=''
REPOSITORY=''
DIRECTORY=''
FILTER=''
VERBOSE=''
SILENT=''
DRY_RUN=''
REST=''
parse_pull() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[brdf]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
        ;;
      -[vsnh]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '--config')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        CONFIG="$OPTARG"
        shift ;;
      '-b'|'--branch')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        BRANCH="$OPTARG"
        shift ;;
      '-r'|'--repository')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        REPOSITORY="$OPTARG"
        shift ;;
      '-d'|'--directory')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        DIRECTORY="$OPTARG"
        shift ;;
      '-f'|'--filter')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        FILTER="$OPTARG"
        shift ;;
      '-v'|'--verbose')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        VERBOSE="$OPTARG"
        ;;
      '-s'|'--silent')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        SILENT="$OPTARG"
        ;;
      '-n'|'--dry-run')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        DRY_RUN="$OPTARG"
        ;;
      '-h'|'--help')
        usage_pull
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage_pull() {
cat<<'GETOPTIONSHERE'
Usage: atlas pull [options...] [arguments...]
Options:
      --config CONFIG         path to alternative atlas.yaml configuration file
  -b, --branch BRANCH         A branch of translation files
  -r, --repository REPOSITORY The repository containing translation files
  -d, --directory DIRECTORY   Directory (name of the repository) containing translations to be downloaded
  -f, --filter FILTER         List of patterns to select which files and sub-directories to checkout.
  -v, --verbose               verbose output to terminal
  -s, --silent                no output to terminal
  -n, --dry-run               Do not copy files. Print sparse-checkout rules, git checkout tree and copied tree.
  -h, --help                  
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end

parse_yaml() {
    # adapted from https://gist.github.com/pkuczynski/8665367
    local prefix=$2
    local s='[[:space:]]*' w='[a-zA-Z0-9_]*'
    local fs
    fs=$(echo @|tr @ '\034')
    sed -ne "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  "$1" |
    awk -F"$fs" '{
        indent = length($1)/2;
        vname[indent] = $2;
        for (i in vname) {if (i > indent) {delete vname[i]}}
        if (length($3) > 0) {
            vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
            printf("%s%s%s=\"%s\"\n", "'"$prefix"'",vn, $2, $3);
        }
    }'
}

set_pull_params() {
  # Set vars from config yaml
  if [ "$CONFIG" ];
  then
    if [ -f "$CONFIG" ]; then
      eval "$(parse_yaml "$CONFIG")"
    else
      echo "$CONFIG does not exist."
      exit
    fi
  else
    if [ -f atlas.yml ]; then
      eval "$(parse_yaml atlas.yml)"
    else
      pull_directory=""
      pull_repository="openedx/openedx-translations"
      pull_branch="main"
      pull_filter=""
    fi
  fi

  # Override vars based on args
  if [ "$DIRECTORY" ];
  then
      pull_directory=$DIRECTORY
  fi

  if [ "$REPOSITORY" ];
  then
      pull_repository=$REPOSITORY
  fi

  if [ "$BRANCH" ];
  then
      pull_branch=$BRANCH
  fi

  if [ "$FILTER" ];
  then
      pull_filter="$FILTER"
  fi

  pull_filter="$(echo "$pull_filter" | tr ',' ' ')"  # Accept comma and/or space separated directories list
}

display_pull_params() {
  # Output configured vars to user
  echo "Pulling translation files"
  echo " - directory: ${pull_directory:-Not Specified}"
  echo " - repository: ${pull_repository:-Not Specified}"
  echo " - branch: ${pull_branch:-Not Specified}"
  echo " - filter: ${pull_filter:-Not Specified}"
}

print_directory_tree() {
    # Use `$ tree` when available with a fallback to `$ find . -type f`
    if ! tree 2>/dev/null;
    then
        echo
        find . -type f
        echo
    fi
}

pull_translations() {
  if [ -z "$SILENT" ];
  then
    echo "Creating a temporary Git repository to pull translations into \"./translations_TEMP\"..."
  fi

  # Create temp dir for translations
  mkdir translations_TEMP
  cd translations_TEMP || exit

  # use git in quiet mode when verbose isn't set
  if [ "$VERBOSE" ];
  then
    quiet=""
  else
    quiet="--quiet"
  fi

  # Initialize git repo and add remote
  git init $quiet -b main
  remote_url="https://github.com/$pull_repository.git"
  if [ "$quiet" ];
  then
    # git remote doesn't support `--quiet`
    # redirect git output to /dev/null if we aren't in verbose mode
    git remote add -f origin "$remote_url" &> /dev/null
  else
    git remote add -f origin "$remote_url"
  fi

  # finished "Creating a temporary Git repository to pull translations into <temp dir>..." step
  if [ -z "$SILENT" ];
  then
    echo "Done."

    echo "Pulling translations into \"./translations_TEMP/$pull_directory\"..."
  fi

  # If a directory is specified, configure git for a sparse checkout
  if [ "$pull_directory" ];
  then
    # Reset git sparse-checkout list of include/exclude files
    # Tells sparse checkout to ignore all files, except when otherwise noted
    # See https://www.git-scm.com/docs/git-sparse-checkout for detailed implementation
    git sparse-checkout set "!*"

    if [ "$pull_filter" ];
    then
        for one_filter in $pull_filter;
        do
            # Include directories that matches the language pattern e.g. `/ar/`
            git sparse-checkout add "$pull_directory/**/${one_filter}/**"
            # Include files that matches the language pattern e.g. `ar.*`
            git sparse-checkout add "$pull_directory/**/${one_filter}.*"
        done
    else
        git sparse-checkout add "$pull_directory/"
    fi
  fi

  # Retrieve translation files from the repo
  git pull $quiet origin "$pull_branch"

  # Extra debugging output for sparse-checkout with --dry-run flag
  if [ "$DRY_RUN" ] && [ -z "$SILENT" ];
  then
      echo "Done."

      echo "Printing all 'git sparse-checkout' rules:"
      git sparse-checkout list
  fi

  # Remove .git directory
  rm -rf .git

  if [ "$DRY_RUN" ] && [ -z "$SILENT" ];
  then
      echo "Done."

      echo "Listing the sparse-checkout file tree from the checked-out repository:"
      print_directory_tree
  fi

  # Leave the temp dir
  cd ..

  # finished "Pulling translations into <temp dir>..." step
  if [ -z "$SILENT" ];
  then
    echo "Done."

    echo "Copying translations from \"./translations_TEMP/$pull_directory\" to \"./$pull_directory\"..."
  fi

  if [ "$DRY_RUN" ];
  then
    target_directory=translations_traget_TEMP
    mkdir -p translations_traget_TEMP
  else
    target_directory=.
  fi

  # Copy translation files out of the temp dir
  if [ "$pull_directory" ];
  then
    cp -r translations_TEMP/"$pull_directory"/* $target_directory/
  else
    cp -r translations_TEMP/* $target_directory/
  fi

  if [ "$DRY_RUN" ];
  then
    if [ -z "$SILENT" ];
    then
      echo "Done."

      echo "Listing the copied files tree in the local file system:"
      (cd translations_traget_TEMP || exit; print_directory_tree)
      echo "Done."

      echo "Removing temporary translations_traget_TEMP directory..."
    fi
    rm -rf translations_traget_TEMP
  fi

  # finished "Copying translations from <temp dir> to <dest dir>..." step
  if [ -z "$SILENT" ];
  then
    echo "Done."

    echo "Removing temporary directory..."
  fi

  # Remove the temp dir
  rm -rf translations_TEMP

  # finshed "Removing temporary directory..." step
  if [ -z "$SILENT" ];
  then
    echo "Done."

    # finished pulling translations!
    echo ""
    if [ "$DRY_RUN" ];
    then
      echo "Translations pulled successfully in dry-run mode without copying!"
    else
      echo "Translations pulled successfully!"
    fi
  fi
}

# used for shellspec mocking
test || __() { :; }

parse "$@"
eval "set -- $REST"

if [ $# -gt 0 ]; then
	cmd=$1
	shift
	case $cmd in
		pull)
			parse_pull "$@"
      set_pull_params

      if [ -z "$SILENT" ];
      then
        display_pull_params
      fi
      # allow mocking pull_translations
      __ begin_pull_translations_mock __
      pull_translations
      __ end_pull_translations_mock __
      ;;
		--) # no subcommand, arguments only
	esac
fi
